# NPC管理システム

# OOM対策: 定期ポーリングを削除し、on loadのみでNPCリストをキャッシュ
# 必要な場合は /npc-refresh コマンドで手動更新

on load:
    execute "SELECT GROUP_CONCAT(name SEPARATOR '|') as names FROM npcs" in {kenkoku_db} and store the result in {-npc_names_result::*}
    clear {-npc_list_cache::*}
    if {-npc_names_result::*} is set:
        set {_row} to first element of {-npc_names_result::*}
        set {_str} to "%{_row}%"
        replace "names: " with "" in {_str}
        set {_list::*} to split {_str} at "|"
        loop {_list::*}:
            add loop-value to {-npc_list_cache::*}
    # OOM対策: DB結果変数を即座にクリア
    delete {-npc_names_result::*}

# NPC手動更新コマンド（OOM対策のため定期ポーリングを廃止）
command /npc-refresh:
    permission: op
    trigger:
        execute "SELECT GROUP_CONCAT(name SEPARATOR '|') as names FROM npcs" in {kenkoku_db} and store the result in {-npc_names_result::*}
        clear {-npc_list_cache::*}
        if {-npc_names_result::*} is set:
            set {_row} to first element of {-npc_names_result::*}
            set {_str} to "%{_row}%"
            replace "names: " with "" in {_str}
            set {_list::*} to split {_str} at "|"
            loop {_list::*}:
                add loop-value to {-npc_list_cache::*}
        delete {-npc_names_result::*}
        send "&a[System] NPCリストを更新しました。"

# NPCを召喚するコマンド
# NPC召喚関数 (再利用可能)
function spawnNpc(name: text, loc: location, p: player):
    # DB接続チェック
    if {kenkoku_db} is not set:
        broadcast "&c[Error] データベース接続変数 {kenkoku_db} が設定されていません！"
        stop
        
    # NPC基本情報取得
    # NPC基本情報取得
    set {_is_number} to false
    set {_check_id} to {_name} parsed as number
    if {_check_id} is set:
        set {_is_number} to true
        
    if {_is_number} is true:
        # IDまたは名前で検索
        # SkriptのDB連携では変数が自動的にクオートされる可能性があるため、明示的なクオートを避けるか、
        # あるいは文字列結合で対応する。
        # ここではオリジナルが %{_name}% だったことを踏まえ、元に戻しつつID条件を加える。
        execute "SELECT n.id, n.name, n.level, b.key as biome_key, p.key as profession_key, t.name as npc_type FROM npcs n LEFT JOIN biomes b ON n.biome_id = b.id LEFT JOIN professions p ON n.profession_id = p.id LEFT JOIN npc_types t ON n.npc_type_id = t.id WHERE n.id = %{_check_id}% OR n.name = %{_name}% LIMIT 1" in {kenkoku_db} and store the result in {_npc_data::*}
    else:
        # 名前で検索
        execute "SELECT n.id, n.name, n.level, b.key as biome_key, p.key as profession_key, t.name as npc_type FROM npcs n LEFT JOIN biomes b ON n.biome_id = b.id LEFT JOIN professions p ON n.profession_id = p.id LEFT JOIN npc_types t ON n.npc_type_id = t.id WHERE n.name = %{_name}% LIMIT 1" in {kenkoku_db} and store the result in {_npc_data::*}
    
    if {_npc_data::id::*} is not set:
        broadcast "&c[Error] 指定されたNPC (%{_name}%) は見つかりませんでした。"
        stop
        
    set {_id} to {_npc_data::id::1}
    set {_level} to {_npc_data::level::1}
    set {_biome} to {_npc_data::biome_key::1} ? "plains"
    set {_profession} to {_npc_data::profession_key::1} ? "none"
    set {_type_name} to {_npc_data::npc_type::1} ? "villager"
    
    # 村人を召喚
    spawn villager at {_loc}
    set {_npc} to spawned villager
    set display name of {_npc} to {_name}
    
    # NBT設定 (基本)
    set {_base_nbt} to "{VillagerData:{profession:""minecraft:%{_profession}%"",type:""minecraft:%{_biome}%"",level:%{_level}%},NoAI:1b,Invulnerable:1b,PersistenceRequired:1b,CustomNameVisible:1b,Silent:1b}"
    add nbt compound from {_base_nbt} to nbt of {_npc}
    
    # タグ設定
    add "kenkoku_npc" to scoreboard tags of {_npc}
    add "npc_id_%{_id}%" to scoreboard tags of {_npc}
    add "npc_name_%{_name}%" to scoreboard tags of {_npc}
    
    # 取引情報の取得と設定
    execute "SELECT t.id, t.content, i.key as v_key, i.nbt as v_nbt, i.is_original as v_is_orig FROM trades t LEFT JOIN items i ON t.view_item_id = i.id WHERE t.npc_id = %{_id}%" in {kenkoku_db} and store the result in {_npc_trades::*}
    
    # NBTでのレシピ構築
    # リスト変数をループしてレシピNBT文字列を作成
    # レシピ構築用変数
    set {_recipes_nbt} to "["
    set {_first} to true
    
    loop {_npc_trades::id::*}:
        set {_tid} to loop-value
        set {_content} to {_npc_trades::content::%loop-index%}
        
        # ------------------------------------------------------------------
        # 新戦略: SkBeeのSNBTシリアライズを利用する
        # ------------------------------------------------------------------
        
        # 1. Buy Item (取引権) - Hybrid Method
        # Generate a dummy item to get its exact SNBT, matching /get-trading-right logic
        set {_dummy_buy} to wandering trader spawn egg
        
        # 1. Standard Skript Name/Lore
        set name of {_dummy_buy} to "&l取引券"
        set lore of {_dummy_buy} to "&7交易に使用します"
        
        # 2. Complex Components (SkBee)
        # Use same NBT structure as original-item-system.sk
        set {_nbt} to "{enchantment_glint_override:1b,rarity:""uncommon"",entity_data:{id:""minecraft:area_effect_cloud"",Duration:1,Radius:0.01f,Invulnerable:1b},custom_data:{itemType:""tradeTicket""}}"
        
        add nbt compound from {_nbt} to nbt of {_dummy_buy}
        
        # 3. Get Full SNBT for Recipe
        set {_buy_snbt} to full nbt of {_dummy_buy}
        
        # 2. Sell Item (結果アイテム) - view_item_idがあればそれを使う。なければ紙
        set {_v_key} to {_npc_trades::v_key::%loop-index%}
        set {_v_nbt} to {_npc_trades::v_nbt::%loop-index%}
        set {_v_is_orig} to {_npc_trades::v_is_orig::%loop-index%}

        if {_v_key} is set:
            set {_dummy_sell} to {_v_key} parsed as item
            # NBTの適用 (オリジナルアイテムの場合)
            if {_v_is_orig} is true:
                if {_v_nbt} is set:
                    # クォート除去
                    set {_clean_v_nbt} to {_v_nbt}
                    if {_clean_v_nbt} starts with """":
                        set {_len} to length of {_clean_v_nbt}
                        set {_clean_v_nbt} to subtext of {_clean_v_nbt} from 2 to {_len} - 1
                    
                    if {_clean_v_nbt} starts with "[":
                        # Component Syntaxの場合は一度文字列として扱ってからパースする
                        # (表示用なので簡易的な対応)
                        set {_dummy_sell} to "%{_v_key}%%{_clean_v_nbt}%" parsed as item
                    else:
                        add nbt compound from {_clean_v_nbt} to nbt of {_dummy_sell}
        else:
            set {_dummy_sell} to paper

        set name of {_dummy_sell} to {_content}
        
        # Add Trade ID to Custom Data
        set {_nbt_sell} to "{custom_data:{KenkokuTradeId:%{_tid}%}}"
        add nbt compound from {_nbt_sell} to nbt of {_dummy_sell}
        
        set {_sell_snbt} to full nbt of {_dummy_sell}
        
        # 3. レシピ文字列に追加
        # rewardExp:0b (経験値なし), uses:0 (使用回数0), maxUses:2147483647 (無制限)
        if {_first} is true:
            set {_recipes_nbt} to "%{_recipes_nbt}%{buy:%{_buy_snbt}%,sell:%{_sell_snbt}%,rewardExp:0b,uses:0,maxUses:2147483647}"
            set {_first} to false
        else:
            set {_recipes_nbt} to "%{_recipes_nbt}%,{buy:%{_buy_snbt}%,sell:%{_sell_snbt}%,rewardExp:0b,uses:0,maxUses:2147483647}"
        
    set {_recipes_nbt} to "%{_recipes_nbt}%]"
    
    # Offersタグとして追加
    add nbt compound from "{Offers:{Recipes:%{_recipes_nbt}%}}" to nbt of {_npc}
    
    # トレード数をメタデータとして保存
    set {_trade_count} to size of {_npc_trades::id::*}
    set metadata value "trade_count" of {_npc} to {_trade_count}
        
    displayNpcSpawnSuccess({_name}, {_id}, {_trade_count})
    
    
# NPC召喚成功メッセージの表示関数 (分離)
function displayNpcSpawnSuccess(name: text, id: number, trade_count: number):
    broadcast "&a[System] NPC (%{_name}%) を召喚しました！ (ID: %{_id}%, Trades: %{_trade_count}%)"


# NPC召喚用スポーンエッグを与える関数
function giveNpcSpawner(p: player, name: text):
    # 1. データベースから存在するNPCか確認 (ID or Name)
    set {_is_number} to false
    set {_check_id} to {_name} parsed as number
    if {_check_id} is set:
        set {_is_number} to true
        
    delete {_check_name}
    if {_is_number} is true:
        execute "SELECT name FROM npcs WHERE id = %{_check_id}% OR name = %{_name}% LIMIT 1" in {kenkoku_db} and store the result in {_check_res::*}
    else:
        execute "SELECT name FROM npcs WHERE name = %{_name}% LIMIT 1" in {kenkoku_db} and store the result in {_check_res::*}
        
    set {_check_name} to {_check_res::name::1}
    
    if {_check_name} is not set:
        send "&c[Error] 指定されたNPC (%{_name}%) は存在しません。" to {_p}
        stop
    
    # 正規の名称を使用
    set {_name} to {_check_name}
    set {_item_name} to "NPC召喚: %{_name}%"

    # 2. スポーンエッグの生成
    set {_item} to villager spawn egg
    
    # Skript Standard
    set name of {_item} to "&e%{_item_name}%"
    set lore of {_item} to "&7右クリックでNPCを召喚します"
    
    # NBT設定 (カスタムデータ埋め込み)
    set {_nbt} to "{"
    set {_nbt} to "%{_nbt}%enchantment_glint_override:1b,"
    set {_nbt} to "%{_nbt}%rarity:""rare"","
    set {_nbt} to "%{_nbt}%entity_data:{id:""minecraft:area_effect_cloud"",Duration:1,Radius:0.01f,Invulnerable:1b},"
    set {_nbt} to "%{_nbt}%custom_data:{itemType:""npcSpawner"",npcName:""%{_name}%""}"
    set {_nbt} to "%{_nbt}%}"
    
    add nbt compound from {_nbt} to nbt of {_item}
    
    # プレイヤーに付与
    give {_item} to {_p}
    
    # 3. コピー用コマンドの生成 (1.20.5+ Syntax)
    # custom_dataはNBT形式(key:value)だが、Componentのcustom_data={}内ではそれに従う
    # 名前などはJson Component Syntaxが必要
    
    # 表示名 (Yellow & No Italic)
    set {_display_json} to "{""extra"":[{""bold"":false,""italic"":false,""underlined"":false,""strikethrough"":false,""obfuscated"":false,""color"":""yellow"",""text"":""%{_item_name}%""}],""text"":""""}"
    
    # Lore (Gray)
    set {_lore_json} to "[{""extra"":[{""bold"":false,""italic"":false,""underlined"":false,""strikethrough"":false,""obfuscated"":false,""color"":""gray"",""text"":""右クリックでNPCを召喚します""}],""text"":""""}]"
    
    # Command String Construction
    set {_give_nbt} to "enchantment_glint_override=1b,rarity=rare,custom_name='%{_display_json}%',lore=%{_lore_json}%,custom_data={itemType:npcSpawner,npcName:""%{_name}%""},entity_data={id:""minecraft:area_effect_cloud"",Duration:1,Radius:0.01f,Invulnerable:1b}"
    
    set {_command} to "/minecraft:give @p villager_spawn_egg[%{_give_nbt}%] 1"
    
    send "&a[System] NPC召喚エッグを入手しました。" to {_p}
    send formatted "<tooltip:クリックでコピー><copy:%{_command}%>&e[Click to Copy] &7%{_command}%" to {_p}


# NPCを召喚するコマンド (Function呼び出し)
command /spawn-npc <text>:
    permission: op
    usage: /spawn-npc <NPC名>
    trigger:
        giveNpcSpawner(player, arg-1)


# NPC一括更新コマンド
command /npc-update:
    permission: op
    trigger:
        broadcast "&a[System] NPCの更新を開始します..."
        
        # 1. 対象のNPCをマーク
        loop all villagers:
            if scoreboard tags of loop-villager contains "kenkoku_npc":
                add "oldNpc" to scoreboard tags of loop-villager
                
        # 2. マークされたNPCを更新
        set {_count} to 0
        loop all villagers:
            if scoreboard tags of loop-villager contains "oldNpc":
                # 名前を特定
                delete {_target_name}
                loop scoreboard tags of loop-villager:
                    if loop-value-2 starts with "npc_name_":
                        set {_target_name} to loop-value-2
                        replace "npc_name_" with "" in {_target_name}
                
                if {_target_name} is set:
                    set {_loc} to location of loop-villager
                    delete {_p_none}
                    spawnNpc({_target_name}, {_loc}, {_p_none})
                    kill loop-villager
                    add 1 to {_count}
                else:
                    broadcast "&c[Warning] 名前タグが見つからないNPCをスキップしました (Loc: %location of loop-villager%)"
                    remove "oldNpc" from scoreboard tags of loop-villager
                    
        broadcast "&a[System] %{_count}% 体のNPCを更新しました。"

# NPCへのダメージインタラクション
on damage of villager:
    if scoreboard tags of victim contains "kenkoku_npc":
        cancel event

# 取引画面を開いた際（右クリック時）の処理
on rightclick on villager:
    if scoreboard tags of target contains "kenkoku_npc":
        set {_p} to player
        
        # 手持ちの「取引券」をチェック
        set {_has_ticket} to false
        loop all items in {_p}'s inventory:
            set {_nbt} to custom nbt of loop-item
            set {_type} to string tag "itemType" of {_nbt}
            if {_type} is "tradeTicket":
                set {_has_ticket} to true
                stop loop
        
        if {_has_ticket} is false:
            # トレード数に関わらず一律64枚配布
            set {_ticket} to getTradeTicket()
            give 64 of {_ticket} to {_p}
            send "&a[System] 取引に必要な分の取引券 (x64) を受け取りました。" to {_p}
            play sound "entity.experience_orb.pickup" with volume 0.5 to {_p}

# 取引実行時の処理 (Inventory Click + NBT Tag ID)
on inventory click:
    # ---------------------------------------------------------
    # Merchant Inventory のチェック
    # ---------------------------------------------------------
    if "%event-inventory's type%" contains "merchant":
        # 結果スロット(2)をクリックしたかチェック
        if index of event-slot is 2:
            # プレイヤー情報の確保
            set {_player} to player
            
            # Shift-Click (一括取引)
            if "%click type%" contains "SHIFT":
                cancel event
                
                # NBT解析 (Index 2からID取得)
                set {_target_item} to slot 2 of event-inventory
                set {_nbt_str} to "%nbt of {_target_item}%"
                
                if {_nbt_str} contains "KenkokuTradeId:":
                    set {_parts::*} to split {_nbt_str} at "KenkokuTradeId:"
                    set {_val_part} to {_parts::2}
                    set {_sub_parts::*} to split {_val_part} at "}"
                    set {_raw_id} to {_sub_parts::1}
                    set {_sub_parts_2::*} to split {_raw_id} at ","
                    set {_raw_id} to {_sub_parts_2::1}
                    replace all " " with "" in {_raw_id}
                    replace all "}" with "" in {_raw_id}
                    replace all "," with "" in {_raw_id}
                    set {_tid} to {_raw_id} parsed as number
                
                if {_tid} is set:
                    # チケット数確認 (Slot 0)
                    set {_ticket_item} to slot 0 of event-inventory
                    set {_ticket_count} to item amount of {_ticket_item}
                    if {_ticket_item} is air:
                        set {_ticket_count} to 0
                    
                    processBulkTrade({_player}, {_tid}, {_ticket_count})
                else:
                    # IDが取れない場合 (仮想アイテム等)
                    send "&c[System] 取引情報を取得できませんでした (ErrorCode: NBT_PARSE_FAIL)" to {_player}
                
                stop
            
            # 直接スロットを確認してもNBTが空（仮想アイテム）のため、
            # 1 tick 待って、プレイヤーが手に持った（実体化した）アイテムを確認する
            wait 1 tick
            
            set {_cursor_item} to cursor slot of player
            # カーソルになければ、インベントリに入った可能性もある（シフトクリック等）
            # ここでは簡単のためカーソル優先、なければ直近で増えたアイテムを探すロジックが必要だが
            # まずはカーソルチェック
            
            set {_nbt} to nbt of {_cursor_item}
            
            # ID取得試行 (文字列解析による最終手段)
            # SkBeeのNBTオブジェクト操作が不安定なため、確実にログに出ている文字列からパースする
            set {_nbt_str} to "%{_nbt}%"
            # 例: "... KenkokuTradeId:22} ..." または "... KenkokuTradeId:22, ..."
            
            if {_nbt_str} contains "KenkokuTradeId:":
                set {_parts::*} to split {_nbt_str} at "KenkokuTradeId:"
                # _parts::2 は "22}" や "22," で始まる文字列
                set {_val_part} to {_parts::2}
                
                # 数字の後の区切り文字（} または ,）を探す
                # Skriptの split は簡単だが、汎用的にやるなら文字ループが必要。
                # ここでは簡易的に、"}" と "," の両方で split を試みる
                
                # まず "}" で区切る (JSON/SNBTの閉じカッコ)
                set {_sub_parts::*} to split {_val_part} at "}"
                set {_raw_id} to {_sub_parts::1}
                
                # さらに "," で区切る (複数のタグがある場合)
                set {_sub_parts_2::*} to split {_raw_id} at ","
                set {_raw_id} to {_sub_parts_2::1}
                
                # 空白除去 (念のため)
                replace all " " with "" in {_raw_id}
                replace all "}" with "" in {_raw_id}
                replace all "," with "" in {_raw_id}
                
                # 数値変換
                set {_tid} to {_raw_id} parsed as number
            
            # もし取得できなかった場合の処理
            if {_tid} is not set:
                # 古い形式(ルート直下)も念のため確認
                set {_tid} to {_nbt::KenkokuTradeId}
                if {_tid} is not set:
                    stop
            
            # アイテムが見つかったので、変数にセットして後続処理へ
            set {_item} to {_cursor_item}
            
            wait 1 tick
            
            # ---------------------------------------------------------
            # ロジック変更: 取引結果の「地図」を即座に「取引権(紙)」に戻す
            # これにより、取引権は消費されず、結果(とコスト)だけが処理される
            # ---------------------------------------------------------
            
            # プレイヤーの手持ち(カーソル)またはインベントリにある地図を探す
            set {_found_loc} to "none"
            if cursor slot of {_player} is {_item}:
                set {_found_loc} to "cursor"
            else if {_player} has {_item}:
                set {_found_loc} to "inventory"
            
            # 取引権アイテムの返還 (Hybrid Method)
            set {_refund_item} to wandering trader spawn egg
            
            # 1. Standard Skript
            set name of {_refund_item} to "&l取引券"
            set lore of {_refund_item} to "&7交易に使用します"
            
            # 2. Complex Components
            set {_nbt} to "{"
            set {_nbt} to "%{_nbt}%enchantment_glint_override:1b,"
            set {_nbt} to "%{_nbt}%rarity:""uncommon"","
            set {_nbt} to "%{_nbt}%entity_data:{id:""minecraft:area_effect_cloud"",Duration:1,Radius:0.01f,Invulnerable:1b},"
            set {_nbt} to "%{_nbt}%custom_data:{itemType:""tradeTicket""}"
            set {_nbt} to "%{_nbt}%}"
            
            add nbt compound from {_nbt} to nbt of {_refund_item}
            
            set amount of {_refund_item} to item amount of {_item}
            
            if {_found_loc} is "cursor":
                set cursor slot of {_player} to {_refund_item}
            else if {_found_loc} is "inventory":
                remove {_item} from {_player}
                give {_refund_item} to {_player}
            else:
                stop
                
            # ---------------------------------------------------------
            # DB照会 & コストチェック
            # ---------------------------------------------------------
            set {_can_afford} to true
            set {_err_msg} to ""
            
            # Trade IDからNPCタイプを取得してクエストかどうか判定
            execute "SELECT t.name as npc_type FROM trades tr JOIN npcs n ON tr.npc_id = n.id JOIN npc_types t ON n.npc_type_id = t.id WHERE tr.id = %{_tid}% LIMIT 1" in {kenkoku_db} and store the result in {-trade_info::*}
            set {_npc_type} to {-trade_info::npc_type::1}
            
            # クエストの重複受領チェック
            if {_npc_type} is "quest":
                if scoreboard tags of {_player} contains "kenkoku_quest_completed_%{_tid}%":
                    send "&c[System] このクエストは既に完了しています。" to {_player}
                    stop
            
            # 1. コスト情報 (Cost Items + Money)
            delete {-trade_reqs::*}
            execute "SELECT i.key as item_key, IFNULL(i.name, '') as item_name, i.nbt, i.is_original, tc.quantity, tc.price FROM trade_costs tc LEFT JOIN items i ON tc.item_id = i.id WHERE tc.trade_id = %{_tid}%" in {kenkoku_db} and store the result in {-trade_reqs::*}

            # 2. リワード情報 (Reward Items + Money)
            delete {-trade_rewards::*}
            execute "SELECT i.key as item_key, IFNULL(i.name, '') as item_name, i.nbt, i.is_original, r.quantity, r.price FROM rewards r LEFT JOIN items i ON r.item_id = i.id WHERE r.trade_id = %{_tid}%" in {kenkoku_db} and store the result in {-trade_rewards::*}
            
            # 3. 所持チェック
            loop {-trade_reqs::item_key::*}:
                set {_req_key} to loop-value
                set {_req_qty} to {-trade_reqs::quantity::%loop-index%}
                set {_is_orig} to {-trade_reqs::is_original::%loop-index%}
                set {_req_nbt} to {-trade_reqs::nbt::%loop-index%}
                set {_req_name} to {-trade_reqs::item_name::%loop-index%}
                
                # Strip Quotes
                if {_req_nbt} is set:
                    if {_req_nbt} starts with """":
                        set {_len} to length of {_req_nbt}
                        set {_req_nbt} to subtext of {_req_nbt} from 2 to {_len} - 1
                
                # Hybrid Parsing Logic (Removal Step)
                if {_req_key} contains "[":
                    set {_req_item} to {_req_key} parsed as item
                else if {_req_nbt} starts with "[":
                    # set {_req_item} to "%{_req_key}%%{_req_nbt}%" parsed as item
                    # Skipping direct parse for Component Strings to avoid SkBee Errors
                    if {_req_item} is not set:
                        set {_req_item} to {_req_key} parsed as item
                        # Sanitize [k=v] to {k:v} for SkBee
                        set {_len} to length of {_req_nbt}
                        set {_inner} to subtext of {_req_nbt} from 2 to {_len} - 1
                        set {_nbt_fixed} to "{%{_inner}%}"
                        replace all "consumable=" with "consumable:" in {_nbt_fixed}
                        replace all "custom_data=" with "custom_data:" in {_nbt_fixed}
                        replace all "item_name=" with "item_name:" in {_nbt_fixed}
                        replace all "custom_name=" with "ignore_name:" in {_nbt_fixed}
                        replace all "rarity=" with "rarity:" in {_nbt_fixed}
                        # replace all "'" with """" in {_nbt_fixed}
                        # add nbt from {_nbt_fixed} to nbt of {_req_item}
                        
                        # Manual Name Extraction Fallback
                        if name of {_req_item} is not set:
                            if {_nbt_fixed} contains "text:""":
                                set {_parts::*} to {_nbt_fixed} split at "text:"""
                                set {_name_part} to {_parts::2}
                                set {_subparts::*} to {_name_part} split at """"
                                set {_manual_name} to {_subparts::1}
                                set name of {_req_item} to {_manual_name}
                else:
                    set {_req_item} to {_req_key} parsed as item
                    if {_is_orig} is true:
                         # Strict Match Fallback Logic (Only applied if strict match path used)
                        if {_req_nbt} is set:
                            if {_req_nbt} starts with """":
                                set {_len} to length of {_req_nbt}
                                set {_req_nbt} to subtext of {_req_nbt} from 2 to {_len} - 1
                            add nbt compound from {_req_nbt} to nbt of {_req_item}
                
                if {_req_item} is set:
                    # Relaxed Condition Check (Single)
                    if {_is_orig} is true:
                        set {_nbt_compound} to nbt compound of {_req_item}
                        # Custom Data Logic
                        set {_target_type} to ""
                        # Full custom_data Extraction
                        # Full custom_data Extraction (Total Cleanup Strategy)
                        set {_target_custom_data} to ""
                        if {_nbt_fixed} contains "custom_data":
                            set {_nbt_fixed_clean} to "%{_nbt_fixed}%"
                            set {_q} to """"
                            replace all "[" with "" in {_nbt_fixed_clean}
                            replace all "]" with "" in {_nbt_fixed_clean}
                            replace all " " with "" in {_nbt_fixed_clean}
                            replace all {_q} with "" in {_nbt_fixed_clean}
                            replace all "'" with "" in {_nbt_fixed_clean}
                            replace all "minecraft:" with "" in {_nbt_fixed_clean}
                            replace all "=" with ":" in {_nbt_fixed_clean}
                            
                            set {_parts::*} to {_nbt_fixed_clean} split at "custom_data:{"
                            if size of {_parts::*} > 1:
                                set {_val_part} to {_parts::2}
                                set {_subparts::*} to {_val_part} split at "}"
                                set {_target_custom_data} to {_subparts::1}
                        
                        if {_target_custom_data} is not "":
                            set {_amount} to 0
                            loop all items in {_player}'s inventory:
                                set {_req_nbt_check_raw} to full nbt of loop-item
                                set {_nbt_check_clean} to "%{_req_nbt_check_raw}%"
                                set {_q} to """"
                                replace all "[" with "" in {_nbt_check_clean}
                                replace all "]" with "" in {_nbt_check_clean}
                                replace all " " with "" in {_nbt_check_clean}
                                replace all {_q} with "" in {_nbt_check_clean}
                                replace all "'" with "" in {_nbt_check_clean}
                                replace all "minecraft:" with "" in {_nbt_check_clean}
                                replace all "=" with ":" in {_nbt_check_clean}
                                
                                if {_nbt_check_clean} contains "custom_data:{":
                                    set {_inv_parts::*} to {_nbt_check_clean} split at "custom_data:{"
                                    if size of {_inv_parts::*} > 1:
                                        set {_inv_val_part} to {_inv_parts::2}
                                        set {_inv_subparts::*} to {_inv_val_part} split at "}"
                                        set {_inv_custom_data} to {_inv_subparts::1}
                                        
                                        if {_inv_custom_data} is {_target_custom_data}:
                                            add item amount of loop-item to {_amount}
                                else if "%{_req_nbt_check_raw}%" is not "{}":
                                    continue
                        else:
                            # Fallback to Name Comparison (Strip Color) if no itemType found
                            set {_amount} to 0
                            set {_stripped_req} to uncoloured {_req_name}
                            loop all items in {_player}'s inventory:
                                set {_stripped_inv} to uncoloured name of loop-item
                                if {_stripped_inv} is {_stripped_req}:
                                    add item amount of loop-item to {_amount}
                    else:
                        set {_amount} to amount of {_req_item} in {_player}'s inventory
                    
                    if {_amount} < {_req_qty}:
                        set {_can_afford} to false
                        if {_is_orig} is true:
                            set {_err_msg} to "&cアイテムが足りません: %{_req_key}%(Custom) x%{_req_qty}%"
                        else:
                            set {_err_msg} to "&cアイテムが足りません: %{_req_key}% x%{_req_qty}%"
                else:
                    # Parsing Failed
                    set {_can_afford} to false
                    set {_err_msg} to "&c[System] エラー: 要求アイテムの定義が無効です (%{_req_key}%)"
                        
            loop {-trade_reqs::price::*}:
                set {_price} to loop-value
                if {_price} > 0:
                    set {_m} to metadata "money" of {_player}
                    if {_m} is not set:
                        set {_m} to 0
                    if {_m} < {_price}:
                        set {_can_afford} to false
                        set {_err_msg} to "&cお金が足りません: %{_price}%G"
            
            # 4. 取引実行
            if {_can_afford} is true:
                # コスト徴収 (アイテム)
                loop {-trade_reqs::item_key::*}:
                    delete {_req_item}
                    delete {_nbt_fixed}
                    set {_req_key} to loop-value
                    set {_req_qty} to {-trade_reqs::quantity::%loop-index%}
                    set {_is_orig} to {-trade_reqs::is_original::%loop-index%}
                    set {_req_nbt} to {-trade_reqs::nbt::%loop-index%}
                    set {_req_name} to {-trade_reqs::item_name::%loop-index%}
                    
                    # Strip Quotes
                    if {_req_nbt} is set:
                        if {_req_nbt} starts with """":
                            set {_len} to length of {_req_nbt}
                            set {_req_nbt} to subtext of {_req_nbt} from 2 to {_len} - 1
                    
                    # Hybrid Parsing Logic (Removal Step)
                    if {_req_key} contains "[":
                        set {_req_item} to {_req_key} parsed as item
                    else if {_req_nbt} starts with "[":
                        # set {_req_item} to "%{_req_key}%%{_req_nbt}%" parsed as item
                        if {_req_item} is not set:
                            set {_req_item} to {_req_key} parsed as item
                            # Sanitize [k=v] to {k:v} for SkBee
                            set {_len} to length of {_req_nbt}
                            set {_inner} to subtext of {_req_nbt} from 2 to {_len} - 1
                            set {_nbt_fixed} to "{%{_inner}%}"
                            replace all "consumable=" with "consumable:" in {_nbt_fixed}
                            replace all "custom_data=" with "custom_data:" in {_nbt_fixed}
                            replace all "item_name=" with "item_name:" in {_nbt_fixed}
                            replace all "custom_name=" with "custom_name:" in {_nbt_fixed}
                            replace all "rarity=" with "rarity:" in {_nbt_fixed}
                            replace all "'" with """" in {_nbt_fixed}
                            # add nbt from {_nbt_fixed} to nbt of {_req_item}
                    else:
                        set {_req_item} to {_req_key} parsed as item
                        if {_is_orig} is true:
                             # Strict Match Fallback Logic (Only applied if strict match path used)
                            if {_req_nbt} is set:
                                if {_req_nbt} starts with """":
                                    set {_len} to length of {_req_nbt}
                                    set {_req_nbt} to subtext of {_req_nbt} from 2 to {_len} - 1
                                add nbt compound from {_req_nbt} to nbt of {_req_item}
                    
                    # Removal Logic (Decoupled)
                        # Removal Logic (Decoupled & Relaxed)
                    set {_target_custom_data_rem} to ""
                    set {_nbt_to_clean} to ""
                    if {_nbt_fixed} is not "":
                        set {_nbt_to_clean} to {_nbt_fixed}
                    else:
                        set {_nbt_to_clean} to "%{_req_nbt}%"
                        
                    if {_nbt_to_clean} contains "custom_data":
                        set {_nbt_fixed_clean} to "%{_nbt_to_clean}%"
                        set {_q} to """"
                        replace all "[" with "" in {_nbt_fixed_clean}
                        replace all "]" with "" in {_nbt_fixed_clean}
                        replace all " " with "" in {_nbt_fixed_clean}
                        replace all {_q} with "" in {_nbt_fixed_clean}
                        replace all "'" with "" in {_nbt_fixed_clean}
                        replace all "minecraft:" with "" in {_nbt_fixed_clean}
                        replace all "=" with ":" in {_nbt_fixed_clean}
                        
                        set {_parts::*} to {_nbt_fixed_clean} split at "custom_data:{"
                        if size of {_parts::*} > 1:
                            set {_val_part} to {_parts::2}
                            set {_subparts::*} to {_val_part} split at "}"
                            set {_target_custom_data_rem} to {_subparts::1}
                    
                    set {_removed_by_custom} to false
                    if {_target_custom_data_rem} is not "":
                        set {_to_remove} to {_req_qty}
                        loop all items in {_player}'s inventory:
                            if {_to_remove} > 0:
                                set {_req_nbt_check_raw} to full nbt of loop-item
                                if {_req_nbt_check_raw} is not set:
                                    continue
                                set {_nbt_check_clean} to "%{_req_nbt_check_raw}%"
                                set {_q} to """"
                                replace all "[" with "" in {_nbt_check_clean}
                                replace all "]" with "" in {_nbt_check_clean}
                                replace all " " with "" in {_nbt_check_clean}
                                replace all {_q} with "" in {_nbt_check_clean}
                                replace all "'" with "" in {_nbt_check_clean}
                                replace all "minecraft:" with "" in {_nbt_check_clean}
                                replace all "=" with ":" in {_nbt_check_clean}
                                
                                if {_nbt_check_clean} contains "custom_data:{":
                                    set {_inv_parts::*} to {_nbt_check_clean} split at "custom_data:{"
                                    if size of {_inv_parts::*} > 1:
                                        set {_inv_val_part} to {_inv_parts::2}
                                        set {_inv_subparts::*} to {_inv_val_part} split at "}"
                                        set {_inv_custom_data} to {_inv_subparts::1}
                                        if {_inv_custom_data} is {_target_custom_data_rem}:
                                            set {_count} to item amount of loop-item
                                            if {_count} <= {_to_remove}:
                                                remove loop-item from {_player}'s inventory
                                                subtract {_count} from {_to_remove}
                                            else:
                                                set item amount of loop-item to ({_count} - {_to_remove})
                                                set {_to_remove} to 0
                        if {_to_remove} <= 0:
                            set {_removed_by_custom} to true
                    
                    if {_removed_by_custom} is false:
                        if {_is_orig} is true:
                            set {_total_remove} to {_req_qty}
                            set {_removed_count} to 0
                            set {_stripped_req_rem} to uncoloured {_req_name}
                            loop all items in {_player}'s inventory:
                                if {_removed_count} < {_total_remove}:
                                    set {_stripped_inv_rem} to uncoloured name of loop-item
                                    if {_stripped_inv_rem} is {_stripped_req_rem}:
                                        set {_chunk_amt} to item amount of loop-item
                                        set {_needed} to {_total_remove} - {_removed_count}
                                        if {_chunk_amt} <= {_needed}:
                                            remove loop-item from {_player}'s inventory
                                            add {_chunk_amt} to {_removed_count}
                                        else:
                                            remove {_needed} of loop-item from {_player}'s inventory
                                            add {_needed} to {_removed_count}
                        else:
                            # Vanilla Item
                            remove {_req_qty} of {_req_item} from {_player}
                            
                    if {_is_orig} is true:
                        send "&c- %{_req_key}%(Custom) x%{_req_qty}%" to {_player}
                    else:
                        send "&c- %{_req_key}% x%{_req_qty}%" to {_player}
                
                # コスト徴収 (お金)
                loop {-trade_reqs::price::*}:
                    set {_price} to loop-value
                    if {_price} > 0:
                        set {_m} to metadata "money" of {_player}
                        subtract {_price} from {_m}
                        set metadata "money" of {_player} to {_m}
                        
                        # DB更新
                        set {_uuid} to "%uuid of {_player}%"
                        execute "UPDATE player_information SET money = %{_m}% WHERE player_uuid = %{_uuid}%" in {kenkoku_db}
                        updateSidebar({_player})
                        
                        send "&c- %{_price}%G" to {_player}
                
                # リワード付与
                loop {-trade_rewards::item_key::*}:
                    set {_r_key} to loop-value
                    set {_r_qty} to {-trade_rewards::quantity::%loop-index%}
                    set {_r_is_orig} to {-trade_rewards::is_original::%loop-index%}
                    set {_r_nbt} to {-trade_rewards::nbt::%loop-index%}
                    
                    # Strip Quotes
                    if {_r_nbt} is set:
                        if {_r_nbt} starts with """":
                            set {_len} to length of {_r_nbt}
                            set {_r_nbt} to subtext of {_r_nbt} from 2 to {_len} - 1
                    
                    if {_r_nbt} is set:
                        if {_r_nbt} is not "{}":
                            execute console command "minecraft:give %{_player}% %{_r_key}%%{_r_nbt}% %{_r_qty}%"
                        else:
                            execute console command "minecraft:give %{_player}% %{_r_key}% %{_r_qty}%"
                    else:
                        execute console command "minecraft:give %{_player}% %{_r_key}% %{_r_qty}%"

                    if {_r_is_orig} is true:
                        send "&a+ %{_r_key}%(Custom) x%{_r_qty}%" to {_player}
                    else:
                        send "&a+ %{_r_key}% x%{_r_qty}%" to {_player}
                    
                loop {-trade_rewards::price::*}:
                    set {_r_price} to loop-value
                    if {_r_price} > 0:
                        set {_m} to metadata "money" of {_player}
                        add {_r_price} to {_m}
                        set metadata "money" of {_player} to {_m}
                        
                        # DB更新
                        set {_uuid} to "%uuid of {_player}%"
                        execute "UPDATE player_information SET money = %{_m}% WHERE player_uuid = %{_uuid}%" in {kenkoku_db}
                        updateSidebar({_player})
                        
                        send "&a+ %{_r_price}%G" to {_player}
                
                # クエスト完了タグの付与
                if {_npc_type} is "quest":
                    add "kenkoku_quest_completed_%{_tid}%" to scoreboard tags of {_player}
                
                send "&a[System] 取引成立！"
                
            else:
                # 失敗時: メッセージのみ (アイテムは既に取引権に戻っている)
                send {_err_msg} to {_player}
                send "&c[System] 条件を満たしていないため、取引を実行できませんでした。"

# その他のコマンドは変更なし
on tab complete of "/spawn-npc":
    set tab completions for position 1 to {-npc_list_cache::*}

command /kill-nearby-npc:
    permission: op
    trigger:
        loop all villagers in radius 5 around player:
            if scoreboard tags of loop-entity contains "kenkoku_npc":
                kill loop-entity
                send "&c[System] 近くのNPCを削除しました。"

# NPC Spawner Usage (Right Click Block)
on rightclick with villager spawn egg:
    set {_tool} to player's tool
    set {_nbt} to custom nbt of {_tool}
    set {_type} to string tag "itemType" of {_nbt}
    
    if {_type} is "npcSpawner":
        cancel event
        
        set {_npcName} to string tag "npcName" of {_nbt}
        if {_npcName} is not set:
            send "&c[Error] NPC名が定義されていません。"
            stop
            
        # ターゲット位置の特定 (プレイヤーの位置)
        set {_loc} to location of player
                
        # 向きをプレイヤーに向ける
        set yaw of {_loc} to yaw of player * -1
        
        # 召喚実行
        spawnNpc({_npcName}, {_loc}, player)
        
        # アイテム消費 (サバイバルのみ)
        if gamemode of player is survival:
            remove 1 of {_tool} from player

# ------------------------------------------------------------------
# Shift-Click (一括取引) 用の処理関数
# ------------------------------------------------------------------
function processBulkTrade(p: player, tid: number, ticket_count: number):
    # 1. 基本情報の取得
    execute "SELECT t.name as npc_type FROM trades tr JOIN npcs n ON tr.npc_id = n.id JOIN npc_types t ON n.npc_type_id = t.id WHERE tr.id = %{_tid}% LIMIT 1" in {kenkoku_db} and store the result in {-trade_info::*}
    set {_npc_type} to {-trade_info::npc_type::1}

    # クエスト判定 (上限1)
    if {_npc_type} is "quest":
        if scoreboard tags of {_p} contains "kenkoku_quest_completed_%{_tid}%":
            send "&c[System] このクエストは既に完了しています。" to {_p}
            stop
        set {_limit_quest} to 1
    else:
        set {_limit_quest} to 64

    # DBからコスト・報酬取得
    delete {-trade_reqs::*}
    execute "SELECT i.key as item_key, IFNULL(i.name, '') as item_name, i.nbt, i.is_original, tc.quantity, tc.price FROM trade_costs tc LEFT JOIN items i ON tc.item_id = i.id WHERE tc.trade_id = %{_tid}%" in {kenkoku_db} and store the result in {-trade_reqs::*}
    
    delete {-trade_rewards::*}
    execute "SELECT i.key as item_key, IFNULL(i.name, '') as item_name, i.nbt, i.is_original, r.quantity, r.price FROM rewards r LEFT JOIN items i ON r.item_id = i.id WHERE r.trade_id = %{_tid}%" in {kenkoku_db} and store the result in {-trade_rewards::*}
    
    # 2. 取引可能回数 (N) の計算
    
    # (A) チケット数による制限
    set {_N} to {_ticket_count}
    
    # (B) クエストタイプによる制限
    if {_N} > {_limit_quest}:
        set {_N} to {_limit_quest}
    
    # (C) お金による制限
    set {_m} to metadata "money" of {_p}
    if {_m} is not set:
        set {_m} to 0
        
    loop {-trade_reqs::price::*}:
        set {_price} to loop-value
        if {_price} > 0:
            set {_max_by_money} to ({_m} / {_price}) rounded down
            if {_N} > {_max_by_money}:
                set {_N} to {_max_by_money}
                
    # (D) 必要アイテムによる制限
    loop {-trade_reqs::item_key::*}:
        set {_req_key} to loop-value
        set {_req_qty} to {-trade_reqs::quantity::%loop-index%}
        set {_is_orig} to {-trade_reqs::is_original::%loop-index%}
        set {_req_nbt} to {-trade_reqs::nbt::%loop-index%}
        
        # Strip Quotes
        if {_req_nbt} is set:
            if {_req_nbt} starts with """":
                set {_len} to length of {_req_nbt}
                set {_req_nbt} to subtext of {_req_nbt} from 2 to {_len} - 1
        
        # Hybrid Parsing Logic (Calc Step)
        if {_req_key} contains "[":
             # [Legacy Bad] Full Component String in Key
            set {_req_item} to {_req_key} parsed as item
        else if {_req_nbt} starts with "[":
             # [New] Split Component String (Key + NBT)
            set {_req_item} to "%{_req_key}%%{_req_nbt}%" parsed as item
        else:
             # [Legacy] Key + JSON NBT
            set {_req_item} to {_req_key} parsed as item
            if {_is_orig} is true:
                if {_req_nbt} is set:
                    if {_req_nbt} starts with """":
                        set {_len} to length of {_req_nbt}
                        set {_req_nbt_t} to subtext of {_req_nbt} from 2 to {_len} - 1
                    else:
                        set {_req_nbt_t} to {_req_nbt}
                    add nbt compound from {_req_nbt_t} to nbt of {_req_item}
        
        # Logic Flow: Check Stock
        set {_amount} to 0
        
        if {_is_orig} is true:
            # Check for itemType for Relaxed Matching
            set {_nbt_compound} to nbt compound of {_req_item}
            set {_req_name} to name of {_req_item}
            set {_plain_item} to 1 of type of {_req_item}
            set {_plain_name} to name of {_plain_item}
            
            if {_req_name} is not {_plain_name}:
                # Custom Name Match (Relaxed)
                loop all items in {_p}'s inventory:
                    if name of loop-item is {_req_name}:
                        add item amount of loop-item to {_amount}
            else:
                 # Strict Match (Fallback for unnamed originals or plain items)
                set {_amount} to amount of {_req_item} in {_p}'s inventory
        else:
            # Vanilla Item
            set {_amount} to amount of {_req_item} in {_p}'s inventory
            
        if {_req_item} is set:
            set {_max_by_item} to ({_amount} / {_req_qty}) rounded down
            if {_N} > {_max_by_item}:
                set {_N} to {_max_by_item}

    # (E) ハードリミット (1スタック=64)
    if {_N} > 64:
        set {_N} to 64
        
    # 計算結果チェック
    if {_N} <= 0:
        send "&c[System] 取引に必要なコストが足りません。" to {_p}
        stop

    # 3. ループ実行
    set {_success_count} to 0
    set {_active} to true
    
    loop {_N} times:
        if {_active} is true:
            # Step A: リソース確認 (不足していればActiveをFalseに)
            loop {-trade_reqs::item_key::*}:
                if {_active} is true:
                    set {_req_key_c} to loop-value-2
                    set {_req_qty_c} to {-trade_reqs::quantity::%loop-index%}
                    set {_is_orig_c} to {-trade_reqs::is_original::%loop-index%}
                    set {_req_nbt_c} to {-trade_reqs::nbt::%loop-index%}
                    
                    # Strip Quotes
                    if {_req_nbt_c} is set:
                        if {_req_nbt_c} starts with """":
                            set {_len} to length of {_req_nbt_c}
                            set {_req_nbt_c} to subtext of {_req_nbt_c} from 2 to {_len} - 1
                    
                    # Hybrid Parsing Logic (Condition Step)
                    if {_req_key_c} contains "[":
                        set {_req_item_c} to {_req_key_c} parsed as item
                    else if {_req_nbt_c} starts with "[":
                        # set {_req_item_c} to "%{_req_key_c}%%{_req_nbt_c}%" parsed as item
                        if {_req_item_c} is not set:
                            set {_req_item_c} to {_req_key_c} parsed as item
                            # Sanitize [k=v] to {k:v} for SkBee
                            set {_len} to length of {_req_nbt_c}
                            set {_inner} to subtext of {_req_nbt_c} from 2 to {_len} - 1
                            set {_nbt_fixed} to "{%{_inner}%}"
                            replace all "consumable=" with "consumable:" in {_nbt_fixed}
                            replace all "custom_data=" with "custom_data:" in {_nbt_fixed}
                            replace all "item_name=" with "item_name:" in {_nbt_fixed}
                            replace all "rarity=" with "rarity:" in {_nbt_fixed}
                            # replace all "'" with """" in {_nbt_fixed}
                            # add nbt from {_nbt_fixed} to nbt of {_req_item_c}
                    else:
                        set {_req_item_c} to {_req_key_c} parsed as item
                        if {_is_orig_c} is true:
                            if {_req_nbt_c} is set:
                                if {_req_nbt_c} starts with """":
                                    set {_len} to length of {_req_nbt_c}
                                    set {_req_nbt_c} to subtext of {_req_nbt_c} from 2 to {_len} - 1
                                add nbt compound from {_req_nbt_c} to nbt of {_req_item_c}
                    
                    set {_current_stock} to 0
                    if {_req_item_c} is set:
                        set {_has_stock} to false
                        
                        if {_is_orig_c} is true:
                            # Custom Data String Check
                            set {_current_stock} to 0
                            
                            # Parse expected ItemType from DB NBT (-trade_reqs::nbt::%loop-index%)
                            # Since we don't have the parsed item yet properly, we parse the STRING nbt for itemType
                            # Full custom_data Extraction (Bulk Check)
                            set {_target_custom_data_c} to ""
                            set {_raw_nbt} to {-trade_reqs::nbt::%loop-index%}
                            if {_raw_nbt} contains "custom_data":
                                set {_raw_nbt_clean} to {_raw_nbt}
                                replace all " " with "" in {_raw_nbt_clean}
                                replace all """" with "" in {_raw_nbt_clean}
                                replace all "'" with "" in {_raw_nbt_clean}
                                replace all "[" with "" in {_raw_nbt_clean}
                                replace all "]" with "" in {_raw_nbt_clean}
                                replace all "minecraft:" with "" in {_raw_nbt_clean}
                                replace all "=" with ":" in {_raw_nbt_clean}
                                
                                set {_parts::*} to {_raw_nbt_clean} split at "custom_data:{"
                                if size of {_parts::*} > 1:
                                    set {_val_part} to {_parts::2}
                                    set {_subparts::*} to {_val_part} split at "}"
                                    set {_target_custom_data_c} to {_subparts::1}
                            
                            if {_target_custom_data_c} is not "":
                                loop all items in {_p}'s inventory:
                                    set {_req_nbt_check_raw} to full nbt of loop-item
                                    set {_nbt_check_clean} to "%{_req_nbt_check_raw}%"
                                    set {_q} to """"
                                    replace all "[" with "" in {_nbt_check_clean}
                                    replace all "]" with "" in {_nbt_check_clean}
                                    replace all " " with "" in {_nbt_check_clean}
                                    replace all {_q} with "" in {_nbt_check_clean}
                                    replace all "'" with "" in {_nbt_check_clean}
                                    replace all "minecraft:" with "" in {_nbt_check_clean}
                                    replace all "=" with ":" in {_nbt_check_clean}
                                    
                                    if {_nbt_check_clean} contains "custom_data:{":
                                        set {_inv_parts::*} to {_nbt_check_clean} split at "custom_data:{"
                                        if size of {_inv_parts::*} > 1:
                                            set {_inv_val_part} to {_inv_parts::2}
                                            set {_inv_subparts::*} to {_inv_val_part} split at "}"
                                            set {_inv_custom_data} to {_inv_subparts::1}
                                            
                                            if {_inv_custom_data} is {_target_custom_data_c}:
                                                add item amount of loop-item to {_current_stock}
                            else:
                                # Fallback to strict count if no custom type
                                set {_current_stock} to amount of {_req_item_c} in {_p}'s inventory
                        else:
                            # Vanilla Check
                            set {_current_stock} to amount of {_req_item_c} in {_p}'s inventory
                        
                    else:
                        # Item Parse Failed (Invalid Key)
                        set {_active} to false
                        broadcast "&c[System] エラー: 要求アイテムの定義が無効です (%{_req_key_c}%)"
                        
                    if {_current_stock} < {_req_qty_c}:
                        set {_active} to false
                        set {_active} to false
            
            if {_active} is true:
                loop {-trade_reqs::price::*}:
                    if {_active} is true:
                        set {_price_c} to loop-value-2
                        if {_price_c} > 0:
                            set {_m_c} to metadata "money" of {_p}
                            if {_m_c} < {_price_c}:
                                set {_active} to false

        # Step B: 取引実行 (Activeな場合のみ)
        if {_active} is true:
            # コスト徴収 (アイテム)
            loop {-trade_reqs::item_key::*}:
                delete {_req_item}
                delete {_nbt_fixed}
                set {_req_key} to loop-value-2
                set {_req_qty} to {-trade_reqs::quantity::%loop-index%}
                set {_is_orig} to {-trade_reqs::is_original::%loop-index%}
                set {_req_nbt} to {-trade_reqs::nbt::%loop-index%}
                set {_req_name} to {-trade_reqs::item_name::%loop-index%}
                
                # Strip Quotes
                if {_req_nbt} is set:
                    if {_req_nbt} starts with """":
                        set {_len} to length of {_req_nbt}
                        set {_req_nbt} to subtext of {_req_nbt} from 2 to {_len} - 1
                
                # Hybrid Parsing Logic (Bulk Removal)
                if {_req_key} contains "[":
                    set {_req_item} to {_req_key} parsed as item
                else if {_req_nbt} starts with "[":
                    # set {_req_item} to "%{_req_key}%%{_req_nbt}%" parsed as item
                    if {_req_item} is not set:
                        set {_req_item} to {_req_key} parsed as item
                        # Sanitize [k=v] to {k:v} for SkBee
                        set {_len} to length of {_req_nbt}
                        set {_inner} to subtext of {_req_nbt} from 2 to {_len} - 1
                        set {_nbt_fixed} to "{%{_inner}%}"
                        replace all "consumable=" with "consumable:" in {_nbt_fixed}
                        replace all "custom_data=" with "custom_data:" in {_nbt_fixed}
                        replace all "item_name=" with "item_name:" in {_nbt_fixed}
                        replace all "custom_name=" with "custom_name:" in {_nbt_fixed}
                        replace all "rarity=" with "rarity:" in {_nbt_fixed}
                        replace all "'" with """" in {_nbt_fixed}
                        # add nbt from {_nbt_fixed} to nbt of {_req_item}
                else:
                    set {_req_item} to {_req_key} parsed as item
                    if {_is_orig} is true:
                         # Strict Match Fallback Logic (Only applied if strict match path used)
                        if {_req_nbt} is set:
                            if {_req_nbt} starts with """":
                                set {_len} to length of {_req_nbt}
                                set {_req_nbt} to subtext of {_req_nbt} from 2 to {_len} - 1
                            add nbt compound from {_req_nbt} to nbt of {_req_item}
                
                # Removal Logic (Decoupled)
                    # Removal Logic (Decoupled & Relaxed)
                set {_target_custom_data_rem} to ""
                set {_nbt_to_clean} to ""
                if {_nbt_fixed} is not "":
                    set {_nbt_to_clean} to {_nbt_fixed}
                else:
                    set {_nbt_to_clean} to "%{_req_nbt}%"
                    
                if {_nbt_to_clean} contains "custom_data":
                    set {_nbt_fixed_clean} to "%{_nbt_to_clean}%"
                    set {_q} to """"
                    replace all "[" with "" in {_nbt_fixed_clean}
                    replace all "]" with "" in {_nbt_fixed_clean}
                    replace all " " with "" in {_nbt_fixed_clean}
                    replace all {_q} with "" in {_nbt_fixed_clean}
                    replace all "'" with "" in {_nbt_fixed_clean}
                    replace all "minecraft:" with "" in {_nbt_fixed_clean}
                    replace all "=" with ":" in {_nbt_fixed_clean}
                    
                    set {_parts::*} to {_nbt_fixed_clean} split at "custom_data:{"
                    if size of {_parts::*} > 1:
                        set {_val_part} to {_parts::2}
                        set {_subparts::*} to {_val_part} split at "}"
                        set {_target_custom_data_rem} to {_subparts::1}
                
                set {_removed_by_custom} to false
                if {_target_custom_data_rem} is not "":
                    set {_to_remove} to {_req_qty}
                    loop all items in {_p}'s inventory:
                        if {_to_remove} > 0:
                            set {_req_nbt_check_raw} to full nbt of loop-item
                            if {_req_nbt_check_raw} is not set:
                                continue
                            set {_nbt_check_clean} to "%{_req_nbt_check_raw}%"
                            set {_q} to """"
                            replace all "[" with "" in {_nbt_check_clean}
                            replace all "]" with "" in {_nbt_check_clean}
                            replace all " " with "" in {_nbt_check_clean}
                            replace all {_q} with "" in {_nbt_check_clean}
                            replace all "'" with "" in {_nbt_check_clean}
                            replace all "minecraft:" with "" in {_nbt_check_clean}
                            replace all "=" with ":" in {_nbt_check_clean}
                            
                            if {_nbt_check_clean} contains "custom_data:{":
                                set {_inv_parts::*} to {_nbt_check_clean} split at "custom_data:{"
                                if size of {_inv_parts::*} > 1:
                                    set {_inv_val_part} to {_inv_parts::2}
                                    set {_inv_subparts::*} to {_inv_val_part} split at "}"
                                    set {_inv_custom_data} to {_inv_subparts::1}
                                    if {_inv_custom_data} is {_target_custom_data_rem}:
                                        set {_count} to item amount of loop-item
                                        if {_count} <= {_to_remove}:
                                            remove loop-item from {_p}'s inventory
                                            subtract {_count} from {_to_remove}
                                        else:
                                            set item amount of loop-item to ({_count} - {_to_remove})
                                            set {_to_remove} to 0
                    if {_to_remove} <= 0:
                        set {_removed_by_custom} to true
                
                if {_removed_by_custom} is false:
                    if {_is_orig} is true:
                        set {_total_remove} to {_req_qty}
                        set {_removed_count} to 0
                        set {_stripped_req_rem} to uncoloured {_req_name}
                        loop all items in {_p}'s inventory:
                            if {_removed_count} < {_total_remove}:
                                set {_stripped_inv_rem} to uncoloured name of loop-item
                                if {_stripped_inv_rem} is {_stripped_req_rem}:
                                    set {_chunk_amt} to item amount of loop-item
                                    set {_needed} to {_total_remove} - {_removed_count}
                                    if {_chunk_amt} <= {_needed}:
                                        remove loop-item from {_p}'s inventory
                                        add {_chunk_amt} to {_removed_count}
                                    else:
                                        remove {_needed} of loop-item from {_p}'s inventory
                                        add {_needed} to {_removed_count}
                    else:
                        # Vanilla Item
                        remove {_req_qty} of {_req_item} from {_p}
                         # コスト徴収 (お金)
            loop {-trade_reqs::price::*}:
                set {_price} to loop-value-2
                if {_price} > 0:
                    set {_m} to metadata "money" of {_p}
                    subtract {_price} from {_m}
                    set metadata "money" of {_p} to {_m}
                    
            # リワード付与 (アイテム)
            loop {-trade_rewards::item_key::*}:
                set {_r_key} to loop-value-2
                set {_r_qty} to {-trade_rewards::quantity::%loop-index%}
                set {_r_is_orig} to {-trade_rewards::is_original::%loop-index%}
                set {_r_nbt} to {-trade_rewards::nbt::%loop-index%}
                
                # Strip Quotes
                if {_r_nbt} is set:
                    if {_r_nbt} starts with """":
                        set {_len} to length of {_r_nbt}
                        set {_r_nbt} to subtext of {_r_nbt} from 2 to {_len} - 1
                
                # Hybrid Parsing Logic (Single Trade Reward)
                if {_r_key} contains "[":
                    set {_r_item} to {_r_key} parsed as item
                else if {_r_nbt} starts with "[":
                    set {_r_item} to "%{_r_key}%%{_r_nbt}%" parsed as item
                else:
                    set {_r_item} to {_r_key} parsed as item
                    if {_r_is_orig} is true:
                        if {_r_nbt} is set:
                            if {_r_nbt} starts with """":
                                set {_len} to length of {_r_nbt}
                                set {_r_nbt} to subtext of {_r_nbt} from 2 to {_len} - 1
                            add nbt compound from {_r_nbt} to nbt of {_r_item}
                    
                if {_r_item} is set:
                    give {_r_qty} of {_r_item} to {_p}
                else:
                    # Fallback to command
                    set {_cmd_nbt} to ""
                    if {_r_is_orig} is true:
                        if {_r_nbt} is set:
                            if {_r_nbt} is not "{}":
                                if {_r_key} contains "[":
                                    set {_cmd_nbt} to {_r_nbt}
                                else:
                                    set {_cmd_nbt} to {_r_nbt}
                    
                    if {_r_nbt} is set:
                        if {_r_nbt} is not "{}":
                            execute console command "minecraft:give %{_p}% %{_r_key}%%{_r_nbt}% %{_r_qty}%"
                        else:
                            execute console command "minecraft:give %{_p}% %{_r_key}% %{_r_qty}%"
                    else:
                        execute console command "minecraft:give %{_p}% %{_r_key}% %{_r_qty}%"

                
            # リワード付与 (お金)
            loop {-trade_rewards::price::*}:
                set {_r_price} to loop-value-2
                if {_r_price} > 0:
                    set {_m} to metadata "money" of {_p}
                    add {_r_price} to {_m}
                    set metadata "money" of {_p} to {_m}
            
            # 成功カウント増加
            add 1 to {_success_count}

    # 4. 完了処理 (DB更新・タグ・通知)
    set {_uuid} to "%uuid of {_p}%"
    set {_m_final} to metadata "money" of {_p}
    execute "UPDATE player_information SET money = %{_m_final}% WHERE player_uuid = %{_uuid}%" in {kenkoku_db}
    updateSidebar({_p})
    
    # 5. チケット消費 (Slot 0) - 成功回数分だけ消費
    set {_input_item} to slot 0 of current inventory of {_p}
    set {_current_qty} to item amount of {_input_item}
    set {_new_qty} to {_current_qty} - {_success_count}
    if {_new_qty} <= 0:
        set slot 0 of current inventory of {_p} to air
    else:
        set item amount of slot 0 of current inventory of {_p} to {_new_qty}
    
    if {_npc_type} is "quest":
        if {_success_count} > 0:
            add "kenkoku_quest_completed_%{_tid}%" to scoreboard tags of {_p}
            
    # 取引権(チケット)の返還
    if {_success_count} > 0:
        # Legacy item removal/check (if needed)
        # ...
        
        # 新しいアイテム (Hybrid Method)
        set {_item} to wandering trader spawn egg
        
        # 1. Standard Skript
        set name of {_item} to "&l取引券"
        set lore of {_item} to "&7交易に使用します"
        
        # 2. Complex Components
        set {_nbt} to "{"
        set {_nbt} to "%{_nbt}%enchantment_glint_override:1b,"
        set {_nbt} to "%{_nbt}%rarity:""uncommon"","
        set {_nbt} to "%{_nbt}%entity_data:{id:""minecraft:area_effect_cloud"",Duration:1,Radius:0.01f,Invulnerable:1b},"
        set {_nbt} to "%{_nbt}%custom_data:{itemType:""tradeTicket""}"
        set {_nbt} to "%{_nbt}%}"
        
        add nbt compound from {_nbt} to nbt of {_item}
        
        give {_success_count} of {_item} to {_p}
    
    send "&a[System] %{_success_count}% 回分の取引を一括完了しました。" to {_p}

